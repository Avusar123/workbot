# Бот-сервис для поиска вакансий

**Цель**: Создание Telegram-бота, который агрегирует вакансии из разных источников, приводит их к единому формату и предоставляет удобные инструменты фильтрации и подписки на интересующие предложения.

## Используемый стек

- Java 23, Spring Boot, Spring JPA, Spring Web
- PostgreSQL, Liquibase, Redis
- Docker, Docker Compose
- Prometheus, Grafana
- Github Actions
- JUnit, Mockito
- Библиотека для работы с API Telegram

## Реализованный функционал

**Работа с подписками:**

- Просмотр списка текущих подписок с указанием их количества и возможностью просмотреть каждую
- Добавление новой подписки через ввод названия и поэтапное создание детализированного фильтра
- Возможность удаление подписки (изменять подписку нельзя)
  
**Работа с поиском**:

- Просмотр всех актуальных вакансий, попадающих под фильтр
- Вывод результатов через динамическую пагинацию

**Мощная система фильтрации вакансий:**

- Выбор направления (IT, работа с клиентами и др.)
- Динамическая подгрузка компаний (провайдеров) по выбранному направлению
- Групповая и одиночная селекция провайдеров (кнопки Выбрать все / Убрать все)
- Настройка ключевых слов - специальных комбинаций символов, перечисляемых через запятую, работающие в формате логического ИЛИ, которые необходимо найти в описании вакансии или в ее названии
- Задание временных рамок по дате публикации вакансии (1 день, неделя, месяц, 6 месяцев, год)

**Парсинг вакансий:**

- Автоматический воркер периодически проверяет всех провайдеров на наличие изменений и тут же обновляет БД
- Пользователя предупреждают о текущем обновлении и возможных проблемах с производительностью
- Автоматическая рассылка новых вакансий по подпискам запускается сразу после публикации

## Описание структуры проекта

Проект реализован по классической трёхслойной схеме, где роль web-слоя выполняет сам Telegram-бот, напрямую взаимодействующий с пользователем. Сейчас приложение монолитное, но внутри выделены два параллельных потока:

1. **Поток обновления вакансий**  
    Отвечает за получение свежих данных из внешних источников и передачу их в ядро приложения.
    
2. **Основной поток приложения**  
    Обрабатывает пользовательские команды и запросы по уже полученным данным.

### Основные абстракции основного потока

- **Intent**  
    Абстрактный класс-обертка для любых входящих запросов (команд Telegram или внутренних отправок), чтобы привести их к единому типу.    
- **Executor**  
    Параметризованный абстрактный класс, который:
    - Фильтрует Intents нужного типа или по условию.
    - Вызывает соответствующий Handler для дальнейшей обработки.
- **Handler**  
    Конкретные классы с методами, выполняющими логику и работающими с Telegram API (отправка сообщений, построение клавиатуры и т. д.).
### Взаимодействие компонентов

-  **TelegramProcessor** и **ExternalProcessor** принимают «сырой» ввод (команды пользователей или обновлённые вакансии), упаковывают данные в Intent и передают в
-  **HandlerEntrypoint**, где выбирается нужный Executor.
-   Executor делегирует работу соответствующему Handler, и тот выполняет нужную операцию.

Такая архитектура обеспечивает:

- **Унификацию входящих запросов** благодаря Intent.
- **Гибкость расширения** - один Handler можно переиспользовать в разных сценариях.
- **Ясное разделение ответственности** между приёмом данных, маршрутизацией и бизнес-логикой.

## Реализация фильтрации

В основе механизма фильтрации лежит Spring Data Criteria API, который позволяет динамически строить сложные SQL-запросы. Фильтрация работает в двух сценариях:

1. **Поиск подписок, «срабатывающих» на новые вакансии**
    
    - Каждая подписка по сути представляет собой долговременный фильтр, хранящий набор параметров (направления, провайдеры, ключевые слова, временные рамки).
    - При поступлении обновлённых вакансий мы создаём `CriteriaQuery<Subscription>` с условиями по всем полям фильтра внутри подписки и выполняем его, чтобы получить список тех подписок, для которых новая вакансия подходит.
    - После этого каждому найденному подписчику рассылаются уведомления.
        
2. **Поиск вакансий по заданному фильтру**
    
    - Когда пользователь инициирует моментальный поиск, мы строим `CriteriaQuery<Vacancy>` на основе введённых фильтров.
    - Для ключевых слов автоматически формируются серии `LIKE`-условий, объединённые через `OR`, что позволяет искать вакансии, содержащие любое из заданных слов.
    - Дополнительные условия (направление, дата публикации, провайдеры) добавляются в `WHERE` через `AND`, обеспечивая точную стыковку параметров.

## Реализация динамической пагинации и управления контекстом

Чтобы эффективно работать с большим числом провайдеров и вакансий, реализована система динамической пагинации на базе Spring Data JPA и Redis:
- **Хранение фильтра, а не данных**  
    При первом запросе поиска в Redis сохраняется не результат, а сам объект фильтра (DTO с параметрами направления, ключевых слов, даты и др.).
- **Постраничная навигация**  
    При нажатии "Следующая страница" бот извлекает фильтр из Redis, добавляет смещение, после чего выполняет новый JPA-запрос. Таким образом каждый раз возвращается только следующая порция данных, без дублирования и лишней нагрузки.
- **Контексты для инлайн-кнопок**  
    Все кнопки обрабатываются через "контексты" - лёгкие DTO, хранящие:
    - текущий фильтр и параметры пагинации
    - прочие данные, к примеру "сырой" апдейт телеграмма
- **Хранилище контекстов**  
    Контексты живут в Redis и быстро доступны по уникальному ключу, состоящему из Id сообщения и Id чата.

### Метрики и CI

- При ошибках парсинга или получения данных от провайдеров бот мгновенно шлёт администратору в Telegram подробный отчёт с описанием проблемы и стеком ошибок.
- Развёрнут Prometheus для сбора метрик приложения.
- Настроена Grafana с кастомными дашбордами по ключевым показателям.
- Созданы правила оповещений в Grafana, которые при недоступности health-чеков автоматически триггерят уведомления на Email.
- Настроен автоматический CI на GitHub Actions, при каждом пуше запускаются юнит- и интеграционные тесты, проверяется качество кода и возможность корректной сборки приложения.
  
### Развертывание

**Многие российские компании не позволяют отправлять запросы из зарубежных стран, поэтому возможны проблемы с парсингом при использовании VPN**

Для запуска приложения можно использовать профиль `test`, который автоматически заменит все бины работы с телеграмм на заглушки. Если требуется полноценный запуск, можно в `.env` файле прописать `TG_TOKEN` и `TG_ADMIN` (Id чата с администратором).

Все нужные зависимости уже включены в файл `docker-compose.yml`, соответственно, чтобы запустить проект требуется выполнить `docker compose up`. После чего по адресу `localhost:3000` можно зайти в интерфейс grafana, где уже настроена связь с Prometheus, созданы дашборды и алерты. 

В логах будет информация об успешности парсинга и попытки выполнить действия через Telegram API в случае ошибок парсинга.
